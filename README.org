#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:nil |:t
#+TITLE: C++ Replay Buffer (Python module written by C++)
#+DATE: <2019-01-29 Tue>
#+AUTHOR: Hiroyuki Yamada
#+EMAIL: yamada@ymdMBP
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 26.1 (Org mode 9.1.14)

#+HUGO_WITH_LOCALE:
#+HUGO_FRONT_MATTER_FORMAT: toml
#+HUGO_LEVEL_OFFSET: 1
#+HUGO_PRESERVE_FILLING:
#+HUGO_DELETE_TRAILING_WS:
#+HUGO_SECTION: overview
#+HUGO_BUNDLE:
#+HUGO_BASE_DIR: ./site
#+HUGO_CODE_FENCE:
#+HUGO_USE_CODE_FOR_KBD:
#+HUGO_PREFER_HYPHEN_IN_TAGS:
#+HUGO_ALLOW_SPACES_IN_TAGS:
#+HUGO_AUTO_SET_LASTMOD:
#+HUGO_CUSTOM_FRONT_MATTER:
#+HUGO_BLACKFRIDAY:
#+HUGO_FRONT_MATTER_KEY_REPLACE:
#+HUGO_DATE_FORMAT: %Y-%m-%dT%T%z
#+HUGO_PAIRED_SHORTCODES:
#+HUGO_PANDOC_CITATIONS:
#+BIBLIOGRAPHY:
#+HUGO_ALIASES:
#+HUGO_AUDIO:
#+DESCRIPTION:
#+HUGO_DRAFT:
#+HUGO_EXPIRYDATE:
#+HUGO_HEADLESS:
#+HUGO_IMAGES:
#+HUGO_ISCJKLANGUAGE:
#+KEYWORDS:
#+HUGO_LAYOUT:
#+HUGO_LASTMOD:
#+HUGO_LINKTITLE:
#+HUGO_LOCALE:
#+HUGO_MARKUP:
#+HUGO_MENU:
#+HUGO_MENU_OVERRIDE:
#+HUGO_OUTPUTS:
#+HUGO_PUBLISHDATE:
#+HUGO_SERIES:
#+HUGO_SLUG:
#+HUGO_TAGS:
#+HUGO_CATEGORIES:
#+HUGO_RESOURCES:
#+HUGO_TYPE:
#+HUGO_URL:
#+HUGO_VIDEOS:
#+HUGO_WEIGHT: auto

#+STARTUP: showall logdone


* DONE Overview
CLOSED: [2019-02-11 Mon 09:02]
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:END:

Complicated calculation (e.g. Segment Tree) are offloaded onto C++
which must be much faster than Python.

Internal C++ classes and corresponding Python wrapper classes share
memory by [[https://cython.readthedocs.io/en/latest/src/userguide/buffer.html][implementing buffer protocol on cython]] to avoid overhead of
copying large data.


* DONE Requirements
CLOSED: [2019-02-11 Mon 09:03]
:PROPERTIES:
:EXPORT_FILE_NAME: requirements
:END:

- C++17 (at least GCC 7.2)
- Python 3
- Cython (>= 0.29)

We use [[https://cython.org/][Cython]] to write C++ extension for Python, so that you need
Cython to build our packages on your computer.

We observed a build failure with Cython 0.28.5 ([[https://gitlab.com/ymd_h/cpprb/issues/20][#20]] Japanese).

Cython can be installed by =pip=.

#+BEGIN_SRC shell
pip install cython
#+END_SRC

We uses many C++17 features, such as =if constexpr=, structured
bindings, etc., and we highly recommend to use recent gcc, which we
use to build and test.


* DONE Installation
CLOSED: [2019-02-11 Mon 09:05]
:PROPERTIES:
:EXPORT_FILE_NAME: installation
:END:

#+BEGIN_SRC shell
git clone https://gitlab.com/ymd_h/cpprb.git cpprb
cd cpprb
python setup.py build
python setup.py install
#+END_SRC

Depending on your environment, you might need to set =CC= and/or =CXX=
variables like ~CXX=g++ python setup.py build~.

You might need =sudo= for installation.

* DONE Usage
CLOSED: [2019-02-11 Mon 09:06]
:PROPERTIES:
:EXPORT_FILE_NAME: simple_usage
:END:

A simple example is following;
#+BEGIN_SRC python
from cpprb import ReplayBuffer

buffer_size = 256
obs_dim = 3
act_dim = 1
rb = ReplayBuffer(buffer_size,obs_dim,act_dim)

obs = np.ones(shape=(obs_dim))
act = np.ones(shape=(act_dim))
rew = 0
next_obs = np.ones(shape=(obs_dim))
done = 0

for i in range(500):
    rb.add(obs,act,rew,next_obs,done)


batch_size = 32
sample = rb.sample(batch_size)
# sample is a dictionary whose keys are 'obs', 'act', 'rew', 'next_obs', and 'done'
#+END_SRC

* Classes
=ReplayBuffer=, =PrioritizedReplayBuffer=, =NstepReplayBuffer=,
and =NstepPrioritizedReplayBuffer= are supported.

The other classes (including C++ classes) are considered as internal
classes, whose interfaces can change frequently.

** ReplayBuffer
=ReplayBuffer= is a basic replay buffer, where we pick up each time
point randomly. (Duplicated pick up is allowed.)

** PrioritizedReplayBuffer
=PrioritizedReplayBuffer= is a prioritized replay buffer, where you
can set importance (e.g. TD error) to each time point by calling
=PrioritizedReplayBuffer.update_priorities(self,ps)= or
=PrioritizedReplayBuffer.add(self,obs,act,rew,next_obs,done,p)=.
The constructor also take =alpha= parameter, whose default value is =0.6=.
For sampling, you need to pass =beata= argument as well as =batch_size=.

** NstepReplayBuffer
=NstepReplayBuffer= is a N-step reward version of replay buffer. Its
usage is same as =ReplayBuffer=, except whose return value has
=discounts= key. The step size and discount rate are passed to its
constructor as =n_step= (default =4=) and =discount= (default 0.99),
respectively.

** NstepPrioritizedReplayBuffer
=NstepPrioritizedReplayBuffer= is a N-step reward version of
prioritized replay buffer.  The usage is a mixture of
=PrioritizedReplayBuffer= and =NstepReplayBuffer=.

* Test Environment
- GCC 8.2.0
- Python 3.7.2
- Cython 0.29.3
